package planner;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;


/**
 * Provides a method to read in a list of venues from a text file.
 */
public class VenueReader {

	// A List containing all the venues in the order it's contained in a file.
	private static List<Venue> venueList;
	// Traffic description on all corridors of a venue
	// when hosting an event of max size.
	private static Traffic venueT;
	// Traffic generated in a corridor when a venue is
	//  hosting at max capacity.
	private static int cTraffic;
	// Keeps track of line number in a file being read.
	private static int lineNumber;
	// Capacity of a corridor
	private static int corridorCap;
	// Capacity of a venue
	private static int vCapacity;
	// Check if capacity's are integers && >= 0
	private static boolean check;


	/*
	 * invariant:
	 *
	 * venueList != null && venueList.size() >= 0
	 *
	 * For each newVenue in List, none are identical &&
	 * Each corridor c in a newVenue's traffic description, is non-identical.
	 *
	 * For all corridor's in venue's traffic Description
	 * cTraffic <= c.getCapacity() && <= venueT.getCapacity().
	 *
	 */

	/**
	 * <p>
	 * Reads a text file called fileName that describes the venues in a
	 * municipality, and returns a list containing each of the venues read from
	 * the file, in the order that they appear in the file.
	 * </p>
	 *
	 * <p>
	 * The file contains zero or more descriptions of different venues. (I.e. a
	 * file containing zero venues contains zero lines; a file containing one
	 * venue contains exactly one description of a venue and no other lines or
	 * information; a file containing multiple venues contains each description
	 * of a venue, one after the other with no other information or lines in the
	 * file.)
	 * </p>
	 *
	 * <p>
	 * A description of a venue consists of exactly (i) one line consisting of
	 * the name of the venue followed by (ii) one line containing a positive
	 * integer denoting the capacity of the venue followed by (iii) a
	 * description of the traffic generated by hosting an event of maximum size
	 * at the venue, followed by (iv) an empty line.
	 * </p>
	 *
	 * <p>
	 * For (i) the venue name is the entire string on the first line of the
	 * venue description (i.e. it may contain white space characters etc.). The
	 * only constraint on the venue name is that it may not be equal to the
	 * empty string ("").
	 * </p>
	 *
	 * <p>
	 * For (ii) the second line of a venue description may not contain leading
	 * or trailing whitespace characters, it may only contain a positive integer
	 * denoting the venue capacity.
	 * </p>
	 *
	 * <p>
	 * For (iii) the traffic is described by one line for each corridor that
	 * will have traffic from the venue when it hosts an event of maximum size.
	 * Each line is a string of the form <br>
	 * <br>
	 * "START, END, CAPACITY: TRAFFIC"<br>
	 * <br>
	 * where START and END are different non-empty strings denoting the name of
	 * the start location of the corridor and the end location of the corridor,
	 * respectively; CAPACITY is a positive integer denoting the capacity of the
	 * corridor; and TRAFFIC is a positive integer denoting the amount of
	 * traffic from the venue that will use the corridor when the venue hosts
	 * the largest event that it can. The strings denoting the start and end
	 * locations of the corridor may contain any characters other than a comma
	 * (',') or semicolon (':'). Both CAPACITY and TRAFFIC should be positive
	 * integers with no additional leading or trailing whitespace. For example,
	 * <br>
	 * <br>
	 * "St. Lucia, Royal Queensland Show - EKKA, 120: 60"<br>
	 * <br>
	 * represents a traffic corridor from "St. Lucia" to "Royal Queensland Show
	 * - EKKA" with a maximum capacity of 120, that will have 60 people from the
	 * venue using it when the venue hosts an event of maximum size. <br>
	 * <br>
	 * Note that the start, end and capacity of a corridor are separated by the
	 * string ", ". The corridor and its traffic are separated by ": ". <br>
	 * <br>
	 * The corridors and their respective traffic may appear in any order (i.e.
	 * the corridors aren't necessarily sorted in any way.) Each corridor may
	 * only appear once in the traffic description for a venue (i.e. there is
	 * only one line for each corridor), and the traffic on that corridor should
	 * be less than or equal to the capacity of the venue, and less than or
	 * equal to the capacity of the corridor.
	 * </p>
	 *
	 * <p>
	 * For (iv) an empty line is a line with no characters at all (i.e. the
	 * contents of the line is the empty string "").
	 * </p>
	 *
	 * <p>
	 * Two equivalent venues shouldn't appear twice in the file.
	 * </p>
	 *
	 * <p>
	 * If a FormatException is thrown, it will have a meaningful message that
	 * accurately describes the problem with the input file format, including
	 * the line of the file where the problem was detected.
	 * </p>
	 *
	 * @param fileName
	 *            the name of the file to read from.
	 * @return a list of the venues from the file, in the order in which they
	 *         appear in the file.
	 * @throws IOException
	 *             if there is an error reading from the input file.
	 * @throws FormatException
	 *             if there is an error with the input format (e.g. there is
	 *             more than one venue description in the file that describes
	 *             the same venue, or the file format is not as specified above
	 *             in any other way.) The FormatExceptions thrown should have a
	 *             meaningful message that accurately describes the problem with
	 *             the input file format, including the line of the file where
	 *             the problem was detected.
	 */
	public static List<Venue> read(String fileName) throws IOException,
	FormatException {
		FileReader fr = new FileReader(fileName);
		Scanner file = new Scanner(fr);
		venueList = new ArrayList<Venue>();
		lineNumber = 0;
		/*
		 * While loop extracts a venue's info from file
		 * and converts it to object Venue and placed in list<Venue>
		 */
		while (file.hasNext()) {
			file.useDelimiter("\n");
			String name = file.next();
			lineNumber++;
			verifyVenueParam(name, true); // Check venue name is valid
			// Check if venue capacity is valid
			if (check = file.hasNextInt()) {
				vCapacity = Integer.parseInt(file.next()); // venue capacity
				lineNumber++;
			}

			verifyVenueParam("Invalid venue capacity", check);
			venueT = new Traffic(); //zero traffic
			// Process a venue's information from file
			readVenueTraffic(file);
			Venue newVenue = new Venue(name, vCapacity, venueT);
			// Check for duplicate venues
			verifyVenueParam(newVenue, null);
		}
		file.close();
		fr.close();
		return venueList;
	}

	/**
	 * Extracts a venue's information required to  create an instance of Venue
	 * @require venueInfo != null && venueInfo.hasNext()
	 * @ensure vCapacity >= corridorCap >= cTraffic >= 0
	 *
	 *
	 */
	private static void readVenueTraffic(Scanner venueInfo)
			throws FormatException{
		String line;
		venueInfo.useDelimiter(", |: |\n");
		/* process fileInfo of a new venue*/
		line = venueInfo.next();
		lineNumber++;
		// Process a Venue's information
		while(!line.equals("")) {
			Location start = new Location(line); //corridor start location
			Location end = new Location(venueInfo.next());   //corridor end location
			if (check = venueInfo.hasNext()) {
				corridorCap = Integer.parseInt(venueInfo.next()); // corridor capacity
			}
			// Check corridor's capacity is valid
			verifyCorridorParam("venue's corridor traffic invalid", check);
			if (check = venueInfo.hasNextInt()) {
				cTraffic = Integer.parseInt(venueInfo.next()); // corridor traffic
			}
			// Check corridor's traffic is valid
			verifyCorridorParam(" - Traffic is invalid", check);
			verifyCorridorParam(start, end); // Check location names are valid
			verifyCorridorParam(corridorCap, vCapacity); //check if traffic < capacities
			Corridor newC = new Corridor(start, end, corridorCap);
			verifyCorridorParam(venueT, newC); // check for duplicate corridors
			verifyVenueParam(venueInfo, null); // Check for empty line;
			line = venueInfo.next(); // next corridor
			lineNumber++;
		}
	}

	/**
	 * Verifies each Venue's parameters found in the file e.g. name,
	 * capacity are valid. Also  checks for empty line ending of file.
	 *
	 * @require object && object2 are instances of one of the following
	 * (String| Boolean| Venue| Scanner).
	 * @ensure  A Venue's name != null || "" && Venue capacity == Integer &&
	 * 			no duplicate venues are included in List<Venue> && file read
	 * 			contains, the "" at the end of the file (correct formart) .
	 */
	private static void verifyVenueParam(Object object, Object object2)
			throws FormatException {
		// Check venue name is valid and venue capacity is valid
		if (object instanceof String && object2 instanceof Boolean) {
			if (((String)object).length() == 0) {
				// venueName (object) is an empty string
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + "Venue name cannot be empty string");
			} else if ((Boolean)object2 == false || vCapacity < 0) {
				String message = (String)object;
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + message);
			}
			// Check for duplicate venues from file
		} else if (object instanceof Venue) {
			Venue v = (Venue)object;
			if (venueList.contains(v)) {
				// new Venue is already contained in the List<Venue>
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + "Duplicate venues");
			} else {
				venueList.add(v);
			}
			// Check file for empty line
		} else if (object instanceof Scanner) {
			Scanner venueInfo = (Scanner)object;
			if (venueInfo.hasNext() == false) {
				//missing empty line
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + "Missing empty line");
			}

		}
	}

	/**
	 * Ensures the format of the corridor's of a Venue in a file,
	 * meet java doc specifications.
	 * @require object && object2 are instances of one of the following
	 * (Traffic| Corridor| Location| Integer).
	 * @ensure corridor traffic <= corridor capacity <= venue capacity &&
	 * 		   no duplicate corridors for any venue && corridors start & stop
	 * 		   locations, != null || ""
	 */

	private static void verifyCorridorParam(Object object, Object object2)
			throws FormatException {
		// Check for duplicate Corridor
		if(object instanceof Traffic && object2 instanceof Corridor) {
			Traffic venueT = (Traffic)object;
			Corridor newC = (Corridor)object2;
			if (venueT.getTraffic(newC) > 0) {
				// duplicate corridor has been found
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + "Duplicate corridor");
			}
			venueT.updateTraffic(newC, cTraffic);
			// Check for invalid Start or End corridor locations
		} else if (object instanceof Location && object2 instanceof Location) {
			Location start = (Location)object;
			Location end = (Location)object2;
			if (start.toString().equals("")) {
				// Invalid corridor start location
				throw new FormatException("Error on line: " + lineNumber + "\n"
						+"incorrectly formatted corridor, Start is-"+ start.getName());
			} else if (end.toString().equals("")) {
				// Invalid corridor end location
				throw new FormatException("Error on line: " + lineNumber + "\n"
						+"incorrectly formatted corridor, End is -"+ end.getName());
			}
			// Check for traffic exceeding of venue or corridor capacity
		} else if (object instanceof Integer && object2 instanceof Integer) {
			int corridorCap = (Integer)object; //corridor capacity
			int venueCap = (Integer)object2; // venue capacity
			if (cTraffic > venueCap) {
				// Traffic exceed's venue Capacity
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + "traffic exceeds venue capacity");
			} else if (cTraffic > corridorCap) {
				// Traffic exceed's corridor Capacity
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + "traffic exceeds corridor capacity");
			}
			// Check for invalid traffic or corridor capacity ( < 0)
		} else if (object2 instanceof Boolean) {
			String message = (String)object;
			if (check == false || corridorCap < 0) {
				// Traffic is invalid
				throw new FormatException("Error on line: " + lineNumber
						+ "\n"+ message);
			} else if (check == false || cTraffic < 0) {
				// Traffic is invalid
				throw new FormatException("Error on line: " + lineNumber
						+ "\n" + message);
			}
		}
	}
}


